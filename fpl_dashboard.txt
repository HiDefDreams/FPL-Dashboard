import streamlit as st
import pandas as pd
import requests
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import time
import os
import json

# Page configuration
st.set_page_config(
    page_title="FPL Rolling Points Analysis",
    page_icon="‚öΩ",
    layout="wide",
    initial_sidebar_state="expanded"
)

class FPLDataHandler:
    def __init__(self):
        self.base_url = "https://fantasy.premierleague.com/api/"
        self.cache_dir = "fpl_cache"
        os.makedirs(self.cache_dir, exist_ok=True)
        
    def get_cache_file(self, cache_type):
        return os.path.join(self.cache_dir, f"{cache_type}.json")
    
    def is_cache_valid(self, cache_type, max_age_hours=6):
        """Check if cache is still valid"""
        cache_file = self.get_cache_file(cache_type)
        if not os.path.exists(cache_file):
            return False
        
        file_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
        return (datetime.now() - file_time) < timedelta(hours=max_age_hours)
    
    def load_from_cache(self, cache_type):
        """Load data from cache"""
        try:
            cache_file = self.get_cache_file(cache_type)
            if os.path.exists(cache_file):
                with open(cache_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            st.warning(f"Could not load cache: {e}")
        return None
    
    def save_to_cache(self, cache_type, data):
        """Save data to cache"""
        try:
            cache_file = self.get_cache_file(cache_type)
            with open(cache_file, 'w') as f:
                json.dump(data, f)
        except Exception as e:
            st.warning(f"Could not save cache: {e}")
    
    def get_bootstrap_data(self):
        """Get main FPL data with caching"""
        # Try to load from cache first
        if self.is_cache_valid('bootstrap'):
            cached_data = self.load_from_cache('bootstrap')
            if cached_data:
                return cached_data
        
        # Fetch fresh data if cache is invalid or missing
        try:
            response = requests.get(f"{self.base_url}bootstrap-static/", timeout=30)
            response.raise_for_status()
            data = response.json()
            
            # Save to cache
            self.save_to_cache('bootstrap', data)
            return data
            
        except requests.exceptions.RequestException as e:
            st.error(f"‚ùå Error fetching bootstrap data: {e}")
            # Try to return stale cache if available
            cached_data = self.load_from_cache('bootstrap')
            if cached_data:
                st.warning("Using stale cached data as fallback")
                return cached_data
            return None
    
    def get_player_history(self, player_id, player_name=""):
        """Get individual player history with caching"""
        cache_key = f"player_{player_id}"
        
        # Try cache first
        if self.is_cache_valid(cache_key, max_age_hours=24):  # Player data cached longer
            cached_data = self.load_from_cache(cache_key)
            if cached_data:
                return cached_data
        
        # Fetch fresh data
        try:
            response = requests.get(
                f"{self.base_url}element-summary/{player_id}/", 
                timeout=15
            )
            response.raise_for_status()
            data = response.json()
            
            # Save to cache
            self.save_to_cache(cache_key, data)
            return data
            
        except requests.exceptions.RequestException:
            # Try stale cache as fallback
            cached_data = self.load_from_cache(cache_key)
            if cached_data:
                return cached_data
            return None
    
    def get_team_data(self, team_id, gameweek=None):
        """Get FPL team data for a specific team ID"""
        cache_key = f"team_{team_id}_{gameweek if gameweek else 'current'}"
        
        # Try cache first
        if self.is_cache_valid(cache_key, max_age_hours=2):  # Team data cached for 2 hours
            cached_data = self.load_from_cache(cache_key)
            if cached_data:
                return cached_data
        
        # Fetch fresh team data
        try:
            if not gameweek:
                # Get current gameweek from bootstrap
                bootstrap_data = self.get_bootstrap_data()
                if bootstrap_data:
                    for event in bootstrap_data['events']:
                        if event['is_current']:
                            gameweek = event['id']
                            break
            
            if gameweek:
                team_url = f"{self.base_url}entry/{team_id}/event/{gameweek}/picks/"
                response = requests.get(team_url, timeout=15)
                response.raise_for_status()
                team_data = response.json()
                
                # Save to cache
                self.save_to_cache(cache_key, team_data)
                return team_data
                
        except requests.exceptions.RequestException as e:
            st.error(f"Error fetching team data: {e}")
        
        return None
    
    def get_fixtures(self):
        """Get fixture data"""
        cache_key = "fixtures"
        
        if self.is_cache_valid(cache_key, max_age_hours=12):
            cached_data = self.load_from_cache(cache_key)
            if cached_data:
                return cached_data
        
        try:
            response = requests.get(f"{self.base_url}fixtures/", timeout=15)
            response.raise_for_status()
            fixtures = response.json()
            
            self.save_to_cache(cache_key, fixtures)
            return fixtures
        except requests.exceptions.RequestException:
            return None
    
    def calculate_rolling_averages(self, weeks=3, use_progress=True):
        """Calculate rolling averages for all players with enhanced progress tracking"""
        bootstrap_data = self.get_bootstrap_data()
        if not bootstrap_data:
            st.error("‚ùå Could not load FPL data. Check your internet connection.")
            return pd.DataFrame()
        
        players = bootstrap_data['elements']
        teams = {team['id']: team['name'] for team in bootstrap_data['teams']}
        positions = {
            1: 'Goalkeeper', 
            2: 'Defender', 
            3: 'Midfielder', 
            4: 'Forward'
        }
        
        # Find current gameweek
        current_gw = None
        for event in bootstrap_data['events']:
            if event['is_current']:
                current_gw = event['id']
                break
        
        if not current_gw:
            st.warning("No current gameweek found - season may be over")
            return pd.DataFrame()
        
        # Setup progress tracking
        if use_progress:
            st.subheader("üìä Data Collection Progress")
            progress_bar = st.progress(0)
            status_text = st.empty()
            metrics_placeholder = st.empty()
        
        results = []
        processed_count = 0
        successful_count = 0
        start_time = time.time()
        
        for i, player in enumerate(players):
            player_id = player['id']
            player_name = player['web_name']
            team_name = teams[player['team']]
            position = positions[player['element_type']]
            cost = player['now_cost'] / 10  # Convert to millions
            
            # Update progress
            if use_progress:
                progress = (i + 1) / len(players)
                progress_bar.progress(progress)
                
                elapsed_time = time.time() - start_time
                estimated_total = elapsed_time / progress if progress > 0 else 0
                remaining_time = estimated_total - elapsed_time
                
                status_text.text(
                    f"Processing {player_name}... "
                    f"({i+1}/{len(players)}) | "
                    f"Successful: {successful_count} | "
                    f"ETA: {remaining_time:.0f}s"
                )
            
            history_data = self.get_player_history(player_id, player_name)
            processed_count += 1
            
            if not history_data:
                continue
                
            history = history_data.get('history', [])
            
            # Get last X gameweeks with points
            recent_games = [
                game for game in history 
                if game['round'] <= current_gw and game['minutes'] > 0
            ]
            recent_games.sort(key=lambda x: x['round'], reverse=True)
            
            if len(recent_games) >= weeks:
                last_n_games = recent_games[:weeks]
                total_points = sum(game['total_points'] for game in last_n_games)
                rolling_avg = total_points / weeks
                
                # Calculate points per 90 minutes
                total_minutes = sum(game['minutes'] for game in last_n_games)
                ppm90 = (total_points / total_minutes * 90) if total_minutes > 0 else 0
                
                # Additional metrics
                total_goals = sum(game['goals_scored'] for game in last_n_games)
                total_assists = sum(game['assists'] for game in last_n_games)
                total_bonus = sum(game['bonus'] for game in last_n_games)
                
                results.append({
                    'Player': player_name,
                    'Player_ID': player_id,  # Make sure this is always included
                    'Team': team_name,
                    'Position': position,
                    'Cost': f"¬£{cost:.1f}m",
                    'Cost_Numeric': cost,
                    f'Last_{weeks}_GW_Points': total_points,
                    f'Rolling_{weeks}_Week_Avg': round(rolling_avg, 2),
                    'Points_Per_90': round(ppm90, 2),
                    'Goals': total_goals,
                    'Assists': total_assists,
                    'Bonus_Points': total_bonus,
                    'Total_Minutes': total_minutes,
                    'Form': float(player['form']) if player['form'] else 0,
                    'Selected_By': float(player['selected_by_percent']),
                    'ICT_Index': float(player['ict_index']) if player['ict_index'] else 0
                })
                successful_count += 1
        
        # Clear progress indicators
        if use_progress:
            progress_bar.empty()
            status_text.empty()
            if 'metrics_placeholder' in locals():
                metrics_placeholder.empty()
        
        total_time = time.time() - start_time
        st.success(f"‚úÖ Data collection complete! Processed {processed_count} players, {successful_count} with sufficient data in {total_time:.1f} seconds")
        
        df = pd.DataFrame(results)
        if not df.empty:
            df = df.sort_values(f'Rolling_{weeks}_Week_Avg', ascending=False)
            
            # Cache the final results
            cache_key = f"results_{weeks}wk"
            self.save_to_cache(cache_key, {
                'data': df.to_dict('records'),
                'timestamp': datetime.now().isoformat(),
                'gameweek': current_gw
            })
            
        return df

def create_visualizations(df, weeks):
    """Create various charts and visualizations"""
    if df.empty:
        st.warning("No data available for visualizations")
        return None, None, None
    
    # Top players by rolling average
    fig1 = px.bar(
        df.head(15),
        x='Player',
        y=f'Rolling_{weeks}_Week_Avg',
        color='Position',
        title=f"Top 15 Players by {weeks}-Week Rolling Average",
        hover_data=['Team', 'Points_Per_90', 'Cost']
    )
    fig1.update_layout(height=400)
    
    # Points vs Cost scatter plot
    fig2 = px.scatter(
        df.head(50),
        x='Cost_Numeric',
        y=f'Rolling_{weeks}_Week_Avg',
        color='Position',
        size='Points_Per_90',
        hover_name='Player',
        title=f"Value Analysis: {weeks}-Week Average vs Cost",
        labels={'Cost_Numeric': 'Cost (¬£m)', f'Rolling_{weeks}_Week_Avg': 'Rolling Average'}
    )
    fig2.update_layout(height=400)
    
    # Points per 90 distribution by position
    fig3 = px.box(
        df,
        x='Position',
        y='Points_Per_90',
        color='Position',
        title=f"Points Per 90 Distribution by Position (Last {weeks} GWs)"
    )
    fig3.update_layout(height=400)
    
    return fig1, fig2, fig3

def analyze_team_performance(team_id, all_players_df, weeks=3):
    """Analyze a specific FPL team and compare with alternatives"""
    fpl_handler = FPLDataHandler()
    
    st.subheader(f"üîç Analyzing Team #{team_id}")
    
    # Get team data
    with st.spinner("Fetching team data..."):
        team_data = fpl_handler.get_team_data(team_id)
    
    if not team_data:
        st.error(f"Could not fetch team data for ID {team_id}. Please check the team ID and try again.")
        return
    
    # Get player details from picks
    team_players = []
    bootstrap_data = fpl_handler.get_bootstrap_data()
    teams = {team['id']: team['name'] for team in bootstrap_data['teams']}
    positions = {1: 'Goalkeeper', 2: 'Defender', 3: 'Midfielder', 4: 'Forward'}
    
    for pick in team_data['picks']:
        player_id = pick['element']
        player_data = next((p for p in bootstrap_data['elements'] if p['id'] == player_id), None)
        
        if player_data:
            # Find this player in our rolling averages data
            if 'Player_ID' in all_players_df.columns:
                player_rolling_data = all_players_df[all_players_df['Player_ID'] == player_id]
            else:
                # Fallback: try to match by player name and team
                player_name = player_data['web_name']
                team_name = teams[player_data['team']]
                player_rolling_data = all_players_df[
                    (all_players_df['Player'] == player_name) & 
                    (all_players_df['Team'] == team_name)
                ]
            
            if not player_rolling_data.empty:
                player_row = player_rolling_data.iloc[0]
                
                # Get the correct rolling average column name based on weeks
                rolling_avg_col = f'Rolling_{weeks}_Week_Avg'
                
                # Check if the column exists, if not use a default value
                if rolling_avg_col in player_row:
                    rolling_avg = player_row[rolling_avg_col]
                else:
                    # Try to find any rolling average column as fallback
                    rolling_cols = [col for col in player_row.index if col.startswith('Rolling_') and col.endswith('_Week_Avg')]
                    if rolling_cols:
                        rolling_avg = player_row[rolling_cols[0]]
                    else:
                        rolling_avg = 0
                
                team_players.append({
                    'Player': player_data['web_name'],
                    'Player_ID': player_id,
                    'Team': teams[player_data['team']],
                    'Position': positions[player_data['element_type']],
                    'Cost': f"¬£{player_data['now_cost']/10:.1f}m",
                    'Cost_Numeric': player_data['now_cost']/10,
                    'Rolling_Avg': rolling_avg,
                    'Points_Per_90': player_row['Points_Per_90'] if 'Points_Per_90' in player_row else 0,
                    'Form': player_row['Form'] if 'Form' in player_row else 0,
                    'Selected_By': player_row['Selected_By'] if 'Selected_By' in player_row else 0,
                    'Is_Captain': pick['is_captain'],
                    'Is_Vice_Captain': pick['is_vice_captain'],
                    'Multiplier': pick['multiplier']
                })
            else:
                # Player not found in rolling data, use basic info
                team_players.append({
                    'Player': player_data['web_name'],
                    'Player_ID': player_id,
                    'Team': teams[player_data['team']],
                    'Position': positions[player_data['element_type']],
                    'Cost': f"¬£{player_data['now_cost']/10:.1f}m",
                    'Cost_Numeric': player_data['now_cost']/10,
                    'Rolling_Avg': 0,
                    'Points_Per_90': 0,
                    'Form': float(player_data['form']) if player_data['form'] else 0,
                    'Selected_By': float(player_data['selected_by_percent']) if player_data['selected_by_percent'] else 0,
                    'Is_Captain': pick['is_captain'],
                    'Is_Vice_Captain': pick['is_vice_captain'],
                    'Multiplier': pick['multiplier']
                })
    
    if not team_players:
        st.error("No player data found for this team.")
        return
    
    team_df = pd.DataFrame(team_players)
    
    # Display team summary
    st.subheader("üìä Team Summary")
    
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        avg_rolling = team_df['Rolling_Avg'].mean()
        st.metric("Avg Rolling Points", f"{avg_rolling:.2f}")
    with col2:
        total_cost = team_df['Cost_Numeric'].sum()
        st.metric("Total Cost", f"¬£{total_cost:.1f}m")
    with col3:
        captain_df = team_df[team_df['Is_Captain']]
        captain = captain_df['Player'].iloc[0] if not captain_df.empty else "None"
        st.metric("Captain", captain)
    with col4:
        team_size = len(team_df)
        st.metric("Squad Size", team_size)
    
    # Display team players
    st.subheader("üë• Your Team Players")
    
    # Create a display DataFrame with role indicators
    display_df = team_df.copy()
    display_df['Role'] = ''
    display_df.loc[display_df['Is_Captain'], 'Role'] = '¬©'
    display_df.loc[display_df['Is_Vice_Captain'], 'Role'] = 'VC'
    
    # Columns to display
    display_cols = ['Player', 'Role', 'Team', 'Position', 'Cost', 'Rolling_Avg', 'Points_Per_90', 'Form', 'Selected_By']
    
    # Display the dataframe
    st.dataframe(
        display_df[display_cols],
        use_container_width=True
    )
    
    # Show captain info separately
    captain_info = team_df[team_df['Is_Captain']][['Player', 'Rolling_Avg']]
    vice_captain_info = team_df[team_df['Is_Vice_Captain']][['Player', 'Rolling_Avg']]
    
    if not captain_info.empty:
        st.info(f"**Captain**: {captain_info['Player'].iloc[0]} (Rolling Avg: {captain_info['Rolling_Avg'].iloc[0]})")
    if not vice_captain_info.empty:
        st.info(f"**Vice Captain**: {vice_captain_info['Player'].iloc[0]} (Rolling Avg: {vice_captain_info['Rolling_Avg'].iloc[0]})")
    
    # Calculate fixture difficulties for all teams first
    fixtures = fpl_handler.get_fixtures()
    team_difficulties = {}
    
    if fixtures:
        current_gw = next((event['id'] for event in bootstrap_data['events'] if event['is_current']), None)
        
        if current_gw:
            upcoming_gws = range(current_gw + 1, min(current_gw + 4, 39))  # Next 3 GWs
            
            for team_id, team_name in teams.items():
                team_fixtures = [
                    f for f in fixtures 
                    if (f['team_a'] == team_id or f['team_h'] == team_id) and 
                    f['event'] in upcoming_gws and f.get('finished', False) is False
                ]
                
                if team_fixtures:
                    total_difficulty = 0
                    for fixture in team_fixtures:
                        # Determine if home or away and get difficulty
                        if fixture['team_h'] == team_id:
                            difficulty = fixture['team_h_difficulty']
                        else:
                            difficulty = fixture['team_a_difficulty']
                        total_difficulty += difficulty
                    
                    avg_difficulty = total_difficulty / len(team_fixtures)
                    team_difficulties[team_name] = {
                        'avg_difficulty': avg_difficulty,
                        'color': 'üü¢' if avg_difficulty <= 2 else 'üü°' if avg_difficulty <= 3 else 'üî¥',
                        'fixture_count': len(team_fixtures)
                    }
                else:
                    team_difficulties[team_name] = {
                        'avg_difficulty': 'N/A',
                        'color': '‚ö´',
                        'fixture_count': 0
                    }
    
    # Position-wise analysis and alternatives
    st.subheader("üîÑ Position-wise Alternatives")
    
    for position in ['Goalkeeper', 'Defender', 'Midfielder', 'Forward']:
        position_players = team_df[team_df['Position'] == position]
        all_position_players = all_players_df[all_players_df['Position'] == position]
        
        if len(position_players) > 0:
            st.write(f"**{position}s**")
            
            # Create comparison table with detailed alternatives
            comparison_data = []
            
            for _, team_player in position_players.iterrows():
                player_name = team_player['Player']
                player_rolling = team_player['Rolling_Avg']
                player_cost = team_player['Cost_Numeric']
                player_team = team_player['Team']
                
                # Get the correct rolling average column for comparison
                rolling_avg_col = f'Rolling_{weeks}_Week_Avg'
                
                # Check if the column exists in the comparison data
                if rolling_avg_col in all_position_players.columns:
                    # Find better alternatives (higher rolling avg, same or lower cost)
                    alternatives = all_position_players[
                        (all_position_players[rolling_avg_col] > player_rolling) & 
                        (all_position_players['Cost_Numeric'] <= player_cost)  # Same or lower cost only
                    ].head(5)  # Show more alternatives
                else:
                    # If the specific weeks column doesn't exist, use any available rolling average
                    rolling_cols = [col for col in all_position_players.columns if col.startswith('Rolling_') and col.endswith('_Week_Avg')]
                    if rolling_cols:
                        # Use the first available rolling average column
                        alt_rolling_col = rolling_cols[0]
                        alternatives = all_position_players[
                            (all_position_players[alt_rolling_col] > player_rolling) & 
                            (all_position_players['Cost_Numeric'] <= player_cost)
                        ].head(5)
                    else:
                        alternatives = pd.DataFrame()
                
                # Prepare alternatives with fixture information
                alternative_details = []
                for _, alt_row in alternatives.iterrows():
                    alt_team = alt_row['Team']
                    alt_difficulty = team_difficulties.get(alt_team, {'avg_difficulty': 'N/A', 'color': '‚ö´'})
                    
                    alternative_details.append({
                        'Player': alt_row['Player'],
                        'Team': alt_team,
                        'Cost': f"¬£{alt_row['Cost_Numeric']:.1f}m",
                        'Rolling_Avg': alt_row[rolling_avg_col] if rolling_avg_col in alt_row else alt_row.get(alt_rolling_col, 'N/A'),
                        'Fixture_Difficulty': alt_difficulty['avg_difficulty'],
                        'Difficulty_Color': alt_difficulty['color'],
                        'Form': alt_row.get('Form', 0),
                        'Points_Per_90': alt_row.get('Points_Per_90', 0)
                    })
                
                # Sort alternatives by fixture difficulty (easier fixtures first)
                if alternative_details:
                    # Convert N/A to a high number for sorting
                    for alt in alternative_details:
                        if alt['Fixture_Difficulty'] == 'N/A':
                            alt['_sort_difficulty'] = 999
                        else:
                            alt['_sort_difficulty'] = alt['Fixture_Difficulty']
                    
                    alternative_details.sort(key=lambda x: x['_sort_difficulty'])
                    
                    # Remove temporary sort key
                    for alt in alternative_details:
                        del alt['_sort_difficulty']
                
                comparison_data.append({
                    'Your_Player': player_name,
                    'Your_Team': player_team,
                    'Your_Rolling_Avg': player_rolling,
                    'Your_Cost': f"¬£{player_cost:.1f}m",
                    'Your_Form': team_player['Form'],
                    'Your_Fixture_Difficulty': team_difficulties.get(player_team, {'avg_difficulty': 'N/A', 'color': '‚ö´'})['avg_difficulty'],
                    'Your_Difficulty_Color': team_difficulties.get(player_team, {'color': '‚ö´'})['color'],
                    'Alternatives_Count': len(alternative_details),
                    'Top_Alternative': alternative_details[0]['Player'] if alternative_details else "None",
                    'Top_Alternative_Team': alternative_details[0]['Team'] if alternative_details else "N/A",
                    'Top_Alternative_Cost': alternative_details[0]['Cost'] if alternative_details else "N/A",
                    'Top_Alternative_Rolling_Avg': alternative_details[0]['Rolling_Avg'] if alternative_details else "N/A",
                    'Top_Alternative_Fixture_Difficulty': alternative_details[0]['Fixture_Difficulty'] if alternative_details else "N/A",
                    'Top_Alternative_Difficulty_Color': alternative_details[0]['Difficulty_Color'] if alternative_details else "‚ö´",
                    'All_Alternatives': alternative_details  # Store all alternatives for expander
                })
            
            if comparison_data:
                # Create main comparison table
                comp_df = pd.DataFrame(comparison_data)
                
                # Display main comparison
                main_display_cols = [
                    'Your_Player', 'Your_Team', 'Your_Rolling_Avg', 'Your_Cost', 
                    'Your_Fixture_Difficulty', 'Top_Alternative', 'Top_Alternative_Team',
                    'Top_Alternative_Rolling_Avg', 'Top_Alternative_Cost', 'Top_Alternative_Fixture_Difficulty'
                ]
                
                st.dataframe(comp_df[main_display_cols], use_container_width=True)
                
                # Show detailed alternatives in expanders
                for i, row in enumerate(comparison_data):
                    if row['Alternatives_Count'] > 0:
                        with st.expander(f"üîç All alternatives for {row['Your_Player']}"):
                            alt_details = row['All_Alternatives']
                            if alt_details:
                                alt_df = pd.DataFrame(alt_details)
                                display_alt_cols = ['Player', 'Team', 'Cost', 'Rolling_Avg', 'Fixture_Difficulty', 'Difficulty_Color', 'Form', 'Points_Per_90']
                                st.dataframe(alt_df[display_alt_cols], use_container_width=True)
                            else:
                                st.info("No detailed alternatives found.")
    
    # Fixture analysis for upcoming weeks
    st.subheader("üìÖ Upcoming Fixture Analysis")
    
    if fixtures:
        # Get next 3 gameweeks
        current_gw = next((event['id'] for event in bootstrap_data['events'] if event['is_current']), None)
        
        if current_gw:
            upcoming_gws = range(current_gw + 1, min(current_gw + 4, 39))  # Next 3 GWs
            
            fixture_difficulty = {}
            
            for player in team_players:
                player_team_id = next((tid for tid, name in teams.items() if name == player['Team']), None)
                if player_team_id:
                    player_fixtures = [
                        f for f in fixtures 
                        if (f['team_a'] == player_team_id or f['team_h'] == player_team_id) and 
                        f['event'] in upcoming_gws and f.get('finished', False) is False
                    ]
                    
                    if player_fixtures:
                        total_difficulty = 0
                        for fixture in player_fixtures:
                            # Determine if home or away and get difficulty
                            if fixture['team_h'] == player_team_id:
                                difficulty = fixture['team_h_difficulty']
                            else:
                                difficulty = fixture['team_a_difficulty']
                            total_difficulty += difficulty
                        
                        avg_difficulty = total_difficulty / len(player_fixtures)
                        fixture_difficulty[player['Player']] = {
                            'Fixtures': len(player_fixtures),
                            'Avg_Difficulty': avg_difficulty,
                            'Difficulty_Color': 'üü¢' if avg_difficulty <= 2 else 'üü°' if avg_difficulty <= 3 else 'üî¥'
                        }
                    else:
                        # No upcoming fixtures found
                        fixture_difficulty[player['Player']] = {
                            'Fixtures': 0,
                            'Avg_Difficulty': 'N/A',
                            'Difficulty_Color': '‚ö´'
                        }
            
            # Display fixture difficulty
            if fixture_difficulty:
                fixture_rows = []
                for player, info in fixture_difficulty.items():
                    fixture_rows.append({
                        'Player': player,
                        'Upcoming_Fixtures': info['Fixtures'],
                        'Avg_Difficulty': info['Avg_Difficulty'],
                        'Outlook': info['Difficulty_Color']
                    })
                
                fixture_df = pd.DataFrame(fixture_rows)
                st.dataframe(fixture_df, use_container_width=True)
            else:
                st.info("No upcoming fixture data available.")
        else:
            st.info("Current gameweek not found.")
    else:
        st.info("Fixture data not available.")

def main_page(fpl_handler):
    """Main dashboard page"""
    st.title("‚öΩ FPL Rolling Points Analysis Dashboard")
    st.markdown("Track player performance with rolling averages and advanced metrics")
    
    # Cache management
    st.sidebar.subheader("Data Management")
    
    col1, col2 = st.sidebar.columns(2)
    with col1:
        if st.button("üîÑ Refresh All Data"):
            st.cache_data.clear()
            # Clear all cache files
            import glob
            cache_files = glob.glob("fpl_cache/*.json")
            for f in cache_files:
                try:
                    os.remove(f)
                except:
                    pass
            st.rerun()
    
    with col2:
        if st.button("üìä Force New Analysis"):
            st.rerun()
    
    # Cache info
    cache_size = 0
    if os.path.exists("fpl_cache"):
        cache_files = os.listdir("fpl_cache")
        cache_size = len([f for f in cache_files if f.endswith('.json')])
    
    st.sidebar.info(f"üìÅ Cached data: {cache_size} files")
    
    # Weeks selection
    weeks = st.sidebar.slider(
        "Rolling Period (Weeks)",
        min_value=2,
        max_value=6,
        value=3,
        help="Number of recent gameweeks to include in rolling average"
    )
    
    # Position filter
    positions = ['All', 'Goalkeeper', 'Defender', 'Midfielder', 'Forward']
    selected_position = st.sidebar.selectbox("Filter by Position", positions)
    
    # Team filter (will be populated after data load)
    selected_team = 'All'
    
    # Cost filter
    min_cost, max_cost = st.sidebar.slider(
        "Cost Range (¬£m)",
        min_value=4.0,
        max_value=13.0,
        value=(4.0, 13.0),
        step=0.5
    )
    
    # Minimum minutes filter
    min_minutes = st.sidebar.number_input(
        f"Minimum Minutes (Last {weeks} GWs)",
        min_value=0,
        max_value=270 * weeks,
        value=90,
        step=45
    )
    
    # Main content area
    st.subheader(f"Rolling {weeks}-Week Performance Analysis")
    
    # Try to load cached results first
    cached_results = None
    cache_key = f"results_{weeks}wk"
    if fpl_handler.is_cache_valid(cache_key, max_age_hours=6):
        cached_data = fpl_handler.load_from_cache(cache_key)
        if cached_data and 'data' in cached_data:
            cached_results = pd.DataFrame(cached_data['data'])
    
    if cached_results is not None and not st.sidebar.checkbox("Force new data collection", value=False):
        df = cached_results
        st.success(f"üìä Using cached analysis from {len(df)} players")
    else:
        # Collect new data with progress tracking
        with st.spinner("Starting data collection... This may take 2-3 minutes for the first load."):
            df = fpl_handler.calculate_rolling_averages(weeks=weeks, use_progress=True)
    
    if df.empty:
        st.error("""
        No data available. Possible reasons:
        - FPL API is temporarily down
        - Internet connection issues
        - The season hasn't started
        - Rate limiting by FPL
        """)
        return
    
    # Apply filters
    if selected_position != 'All':
        df = df[df['Position'] == selected_position]
    
    df = df[df['Total_Minutes'] >= min_minutes]
    df = df[df['Cost_Numeric'] >= min_cost]
    df = df[df['Cost_Numeric'] <= max_cost]
    
    # Display summary metrics
    st.subheader("Summary Statistics")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Players", len(df))
    with col2:
        avg_points = df[f'Rolling_{weeks}_Week_Avg'].mean()
        st.metric("Average Rolling Points", f"{avg_points:.2f}")
    with col3:
        avg_ppm90 = df['Points_Per_90'].mean()
        st.metric("Average Points/90", f"{avg_ppm90:.2f}")
    with col4:
        if len(df) > 0:
            best_player = df.iloc[0]['Player']
            best_points = df.iloc[0][f'Rolling_{weeks}_Week_Avg']
            st.metric("Top Performer", f"{best_player} ({best_points})")
        else:
            st.metric("Top Performer", "N/A")
    
    # Create and display visualizations
    st.subheader("Performance Visualizations")
    fig1, fig2, fig3 = create_visualizations(df, weeks)
    
    if fig1:
        st.plotly_chart(fig1, use_container_width=True)
        
        col1, col2 = st.columns(2)
        with col1:
            st.plotly_chart(fig2, use_container_width=True)
        with col2:
            st.plotly_chart(fig3, use_container_width=True)
    
    # Data table
    st.subheader("Player Data")
    
    # Column configuration for data table
    display_columns = [
        'Player', 'Team', 'Position', 'Cost', 
        f'Rolling_{weeks}_Week_Avg', 'Points_Per_90',
        'Goals', 'Assists', 'Bonus_Points', 'Form', 'Selected_By'
    ]
    
    st.dataframe(
        df[display_columns],
        use_container_width=True,
        height=400
    )
    
    # Export option
    csv = df.to_csv(index=False)
    st.download_button(
        label="üì• Export to CSV",
        data=csv,
        file_name=f"fpl_rolling_{weeks}_week_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv"
    )
    
    return df

def team_analysis_page(fpl_handler, all_players_df):
    """Team analysis page"""
    st.title("üè† FPL Team Analysis")
    st.markdown("Analyze your FPL team and compare with alternatives")
    
    st.sidebar.subheader("Team Analysis Settings")
    
    # Weeks selection for team analysis
    weeks = st.sidebar.slider(
        "Analysis Period (Weeks)",
        min_value=2,
        max_value=6,
        value=3,
        key="team_weeks",
        help="Number of recent gameweeks to analyze"
    )
    
    # Team ID input
    st.subheader("Enter Your FPL Team ID")
    
    col1, col2 = st.columns([2, 1])
    with col1:
        team_id = st.number_input(
            "FPL Team ID",
            min_value=1,
            max_value=99999999,
            value=12345,  # Default example
            help="You can find your team ID in the URL of your FPL team page: fantasy.premierleague.com/entry/TEAM_ID/event/X"
        )
    
    with col2:
        st.write("")
        st.write("")
        analyze_clicked = st.button("üîç Analyze Team", type="primary")
    
    if analyze_clicked and team_id:
        # Check if we need to refresh the data for team analysis
        required_column = f'Rolling_{weeks}_Week_Avg'
        
        if 'Player_ID' not in all_players_df.columns or required_column not in all_players_df.columns:
            st.warning(f"Cached data is outdated or doesn't have {weeks}-week averages. Refreshing data...")
            with st.spinner(f"Refreshing data with {weeks}-week averages..."):
                all_players_df = fpl_handler.calculate_rolling_averages(weeks=weeks, use_progress=False)
        
        analyze_team_performance(team_id, all_players_df, weeks)
    
    # Instructions
    with st.expander("‚ÑπÔ∏è How to find your FPL Team ID"):
        st.markdown("""
        1. Go to the [Fantasy Premier League website](https://fantasy.premierleague.com)
        2. Log in to your account
        3. Go to your team page
        4. Look at the URL in your browser's address bar
        5. You'll see a URL like: `https://fantasy.premierleague.com/entry/1234567/event/25`
        6. The number after `/entry/` is your Team ID (1234567 in this example)
        """)

def main():
    # Initialize data handler
    fpl_handler = FPLDataHandler()
    
    # Sidebar navigation
    st.sidebar.title("Navigation")
    page = st.sidebar.radio(
        "Go to",
        ["üìä Player Analysis Dashboard", "üè† Team Analysis"]
    )
    
    # Load or calculate player data (needed for both pages)
    with st.spinner("Loading player data..."):
        # Try to load cached data first - default to 3 weeks for main page
        cache_key = "results_3wk"
        all_players_df = None
        
        if fpl_handler.is_cache_valid(cache_key, max_age_hours=6):
            cached_data = fpl_handler.load_from_cache(cache_key)
            if cached_data and 'data' in cached_data:
                all_players_df = pd.DataFrame(cached_data['data'])
                st.sidebar.success("‚úÖ Using cached player data")
        
        if all_players_df is None or all_players_df.empty:
            # Calculate fresh data
            all_players_df = fpl_handler.calculate_rolling_averages(weeks=3, use_progress=False)
    
    # Show appropriate page based on selection
    if page == "üìä Player Analysis Dashboard":
        main_page(fpl_handler)
    elif page == "üè† Team Analysis":
        team_analysis_page(fpl_handler, all_players_df)

if __name__ == "__main__":
    main()